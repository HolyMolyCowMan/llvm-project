; NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
; RUN: llc -O0 -mtriple=aarch64-linux-gnu -global-isel -stop-after=irtranslator %s -o - | FileCheck %s

define { half, half } @test_modf_f16(half %a) {
  ; CHECK-LABEL: name: test_modf_f16
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $h0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(s16) = COPY $h0
  ; CHECK-NEXT:   [[FMODF:%[0-9]+]]:_(s16), [[FMODF1:%[0-9]+]]:_ = G_FMODF [[COPY]]
  ; CHECK-NEXT:   $h0 = COPY [[FMODF]](s16)
  ; CHECK-NEXT:   $h1 = COPY [[FMODF1]](s16)
  ; CHECK-NEXT:   RET_ReallyLR implicit $h0, implicit $h1
  %result = call { half, half } @llvm.modf.f16(half %a)
  ret { half, half } %result
}

define { <2 x half>, <2 x half> } @test_modf_v2f16(<2 x half> %a) {
  ; CHECK-LABEL: name: test_modf_v2f16
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $d0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(<4 x s16>) = COPY $d0
  ; CHECK-NEXT:   [[UV:%[0-9]+]]:_(<2 x s16>), [[UV1:%[0-9]+]]:_(<2 x s16>) = G_UNMERGE_VALUES [[COPY]](<4 x s16>)
  ; CHECK-NEXT:   [[FMODF:%[0-9]+]]:_(<2 x s16>), [[FMODF1:%[0-9]+]]:_ = G_FMODF [[UV]]
  ; CHECK-NEXT:   [[UV2:%[0-9]+]]:_(s16), [[UV3:%[0-9]+]]:_(s16) = G_UNMERGE_VALUES [[FMODF]](<2 x s16>)
  ; CHECK-NEXT:   [[DEF:%[0-9]+]]:_(s16) = G_IMPLICIT_DEF
  ; CHECK-NEXT:   [[BUILD_VECTOR:%[0-9]+]]:_(<4 x s16>) = G_BUILD_VECTOR [[UV2]](s16), [[UV3]](s16), [[DEF]](s16), [[DEF]](s16)
  ; CHECK-NEXT:   [[UV4:%[0-9]+]]:_(s16), [[UV5:%[0-9]+]]:_(s16) = G_UNMERGE_VALUES [[FMODF1]](<2 x s16>)
  ; CHECK-NEXT:   [[BUILD_VECTOR1:%[0-9]+]]:_(<4 x s16>) = G_BUILD_VECTOR [[UV4]](s16), [[UV5]](s16), [[DEF]](s16), [[DEF]](s16)
  ; CHECK-NEXT:   $d0 = COPY [[BUILD_VECTOR]](<4 x s16>)
  ; CHECK-NEXT:   $d1 = COPY [[BUILD_VECTOR1]](<4 x s16>)
  ; CHECK-NEXT:   RET_ReallyLR implicit $d0, implicit $d1
  %result = call { <2 x half>, <2 x half> } @llvm.modf.v2f16(<2 x half> %a)
  ret { <2 x half>, <2 x half> } %result
}

define { float, float } @test_modf_f32(float %a) {
  ; CHECK-LABEL: name: test_modf_f32
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $s0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(s32) = COPY $s0
  ; CHECK-NEXT:   [[FMODF:%[0-9]+]]:_(s32), [[FMODF1:%[0-9]+]]:_ = G_FMODF [[COPY]]
  ; CHECK-NEXT:   $s0 = COPY [[FMODF]](s32)
  ; CHECK-NEXT:   $s1 = COPY [[FMODF1]](s32)
  ; CHECK-NEXT:   RET_ReallyLR implicit $s0, implicit $s1
  %result = call { float, float } @llvm.modf.f32(float %a)
  ret { float, float } %result
}

define { <2 x float>, <2 x float> } @test_modf_v2f32(<2 x float> %a) {
  ; CHECK-LABEL: name: test_modf_v2f32
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $d0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(<2 x s32>) = COPY $d0
  ; CHECK-NEXT:   [[FMODF:%[0-9]+]]:_(<2 x s32>), [[FMODF1:%[0-9]+]]:_ = G_FMODF [[COPY]]
  ; CHECK-NEXT:   $d0 = COPY [[FMODF]](<2 x s32>)
  ; CHECK-NEXT:   $d1 = COPY [[FMODF1]](<2 x s32>)
  ; CHECK-NEXT:   RET_ReallyLR implicit $d0, implicit $d1
  %result = call { <2 x float>, <2 x float> } @llvm.modf.v2f32(<2 x float> %a)
  ret { <2 x float>, <2 x float> } %result
}

define { double, double } @test_modf_f64(double %a) {
  ; CHECK-LABEL: name: test_modf_f64
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $d0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(s64) = COPY $d0
  ; CHECK-NEXT:   [[FMODF:%[0-9]+]]:_(s64), [[FMODF1:%[0-9]+]]:_ = G_FMODF [[COPY]]
  ; CHECK-NEXT:   $d0 = COPY [[FMODF]](s64)
  ; CHECK-NEXT:   $d1 = COPY [[FMODF1]](s64)
  ; CHECK-NEXT:   RET_ReallyLR implicit $d0, implicit $d1
  %result = call { double, double } @llvm.modf.f64(double %a)
  ret { double, double } %result
}

define { <2 x double>, <2 x double> } @test_modf_v2f64(<2 x double> %a) {
  ; CHECK-LABEL: name: test_modf_v2f64
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $q0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(<2 x s64>) = COPY $q0
  ; CHECK-NEXT:   [[FMODF:%[0-9]+]]:_(<2 x s64>), [[FMODF1:%[0-9]+]]:_ = G_FMODF [[COPY]]
  ; CHECK-NEXT:   $q0 = COPY [[FMODF]](<2 x s64>)
  ; CHECK-NEXT:   $q1 = COPY [[FMODF1]](<2 x s64>)
  ; CHECK-NEXT:   RET_ReallyLR implicit $q0, implicit $q1
  %result = call { <2 x double>, <2 x double> } @llvm.modf.v2f64(<2 x double> %a)
  ret { <2 x double>, <2 x double> } %result
}

define { fp128, fp128 } @test_modf_fp128(fp128 %a) {
  ; CHECK-LABEL: name: test_modf_fp128
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $q0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(s128) = COPY $q0
  ; CHECK-NEXT:   [[FMODF:%[0-9]+]]:_(s128), [[FMODF1:%[0-9]+]]:_ = G_FMODF [[COPY]]
  ; CHECK-NEXT:   $q0 = COPY [[FMODF]](s128)
  ; CHECK-NEXT:   $q1 = COPY [[FMODF1]](s128)
  ; CHECK-NEXT:   RET_ReallyLR implicit $q0, implicit $q1
  %result = call { fp128, fp128 } @llvm.modf.fp128(fp128 %a)
  ret { fp128, fp128 } %result
}

define { <2 x fp128>, <2 x fp128> } @test_modf_v2fp128(<2 x fp128> %a) {
  ; CHECK-LABEL: name: test_modf_v2fp128
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $q0, $q1
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(s128) = COPY $q0
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:_(s128) = COPY $q1
  ; CHECK-NEXT:   [[BUILD_VECTOR:%[0-9]+]]:_(<2 x s128>) = G_BUILD_VECTOR [[COPY]](s128), [[COPY1]](s128)
  ; CHECK-NEXT:   [[FMODF:%[0-9]+]]:_(<2 x s128>), [[FMODF1:%[0-9]+]]:_ = G_FMODF [[BUILD_VECTOR]]
  ; CHECK-NEXT:   [[UV:%[0-9]+]]:_(s128), [[UV1:%[0-9]+]]:_(s128) = G_UNMERGE_VALUES [[FMODF]](<2 x s128>)
  ; CHECK-NEXT:   [[UV2:%[0-9]+]]:_(s128), [[UV3:%[0-9]+]]:_(s128) = G_UNMERGE_VALUES [[FMODF1]](<2 x s128>)
  ; CHECK-NEXT:   $q0 = COPY [[UV]](s128)
  ; CHECK-NEXT:   $q1 = COPY [[UV1]](s128)
  ; CHECK-NEXT:   $q2 = COPY [[UV2]](s128)
  ; CHECK-NEXT:   $q3 = COPY [[UV3]](s128)
  ; CHECK-NEXT:   RET_ReallyLR implicit $q0, implicit $q1, implicit $q2, implicit $q3
  %result = call { <2 x fp128>, <2 x fp128> } @llvm.modf.v2fp128(<2 x fp128> %a)
  ret { <2 x fp128>, <2 x fp128> } %result
}

define { float, float } @test_modf_f32_afn(float %a) {
  ; CHECK-LABEL: name: test_modf_f32_afn
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $s0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(s32) = COPY $s0
  ; CHECK-NEXT:   [[FMODF:%[0-9]+]]:_(s32), [[FMODF1:%[0-9]+]]:_ = afn G_FMODF [[COPY]]
  ; CHECK-NEXT:   $s0 = COPY [[FMODF]](s32)
  ; CHECK-NEXT:   $s1 = COPY [[FMODF1]](s32)
  ; CHECK-NEXT:   RET_ReallyLR implicit $s0, implicit $s1
  %result = call afn { float, float } @llvm.modf.f32(float %a)
  ret { float, float } %result
}
